<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Tidy evaluation — tidy-evaluation • rlang</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>

<!-- Bootstrap -->
<link href="../tidyverse.css" rel="stylesheet">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<!-- tidyverse -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>

<!-- mathjax -->
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div class="navbar-brand-container">
        <a class="navbar-brand" href="../index.html">rlang</a>
        <small class="tidyverse">part of the <a href="http://tidyverse.org">tidyverse</a></small>
      </div>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Tidy evaluation</h1>
    </div>

    
    <p>Tidy evaluation is the tidyverse's conception of how to create
domain-specific languages. The most prominent examples of such
sublanguages in R are modelling specifications with formulas
(<code>lm()</code>, <code>lme4::lmer()</code>, etc) and data manipulation grammars
(dplyr, tidyr). Most of these DSLs put dataframe columns in scope
so that users can refer to them directly, saving keystrokes during
interactive analysis and creating easily readable code.</p>
<p>R makes it easy to create DSLs thanks to three features of the
language:</p><ul>
<li><p>R code is first-class. That is, R code can be manipulated like
any other object (see <code><a href='sym.html'>sym()</a></code>, <code><a href='lang.html'>lang()</a></code> and <code><a href='pairlist.html'>node()</a></code> for creating
such objects). We also call <em>expressions</em> these objects
containing R code (see <code><a href='is_expr.html'>is_expr()</a></code>).</p></li>
<li><p>Scope is first-class. Scope is the lexical environment that
associates values to symbols in expressions. Environments can be
created (see <code><a href='env.html'>env()</a></code>) and manipulated as regular objects.</p></li>
<li><p>Finally, functions can capture the expressions that were supplied
as arguments instead of being passed the value of these
expressions (see <code><a href='quosure.html'>enquo()</a></code> and <code><a href='expr.html'>enexpr()</a></code>).</p></li>
</ul>

    <p>To sum up, R functions can capture expressions, manipulate them
like regular objects, and alter the meaning of symbols referenced
in these expressions by changing the scope (the environment) upon
evaluation. This combination of features allow R packages to change
the meaning of R code and create domain-specific sublanguages.</p>
<p>Tidy evaluation is an opinionated approach over how to use these
features to create consistent DSLs. The main principle is that
sublanguages should feel and behave like R code. They change the
meaning of R code, but only in a precise and circumscribed way,
behaving otherwise predictably and in accordance with R
semantics. As a result, users are be able to leverage their
existing knowledge of R programming to solve problems involving the
sublanguage in ways that were not necessarily envisioned or planned
by their designers.</p>
    

        
    <h2 class="hasAnchor" id="parsing-versus-evaluation"><a class="anchor" href="#parsing-versus-evaluation"></a>Parsing versus evaluation</h2>

    
    <p>There are two ways of dealing with unevaluated expressions to
create a sublanguage. The first is to parse the expression
manually, the other is to evaluate the expression in a modified
environment.</p>
<p>Let's take the example of designing a modelling DSL to illustrate
parsing. You would need to traverse the call and analyse all
functions encountered in the expression (in particular, operators
like <code>+</code> or <code>:</code>), building a data structure describing a model as
you go. This method of dealing with expressions is tedious, rigid
and error prone because you're basically rewriting an interpreter
of R code. It is extremely difficult to emulate R semantics when
parsing an expression: does a function take arguments by value or
by expression? Can I parse these arguments? Do these symbols mean
the same thing in this context? Will this argument be evaluated
immediately or later on lazily? Given the difficulty of getting it
right, parsing should be a last resort.</p>
<p>The second way is to rely on evaluation in a specific environment.
The expression is evaluated in an environment where certain objects
and functions are given special definitions. For instance <code>+</code> might
be defined as accumulating vectors in a data structure to build a
design matrix later on, or we might put helper functions in scope
(an example is <code>dplyr::select()</code>). As this method is relying on the
R interpreter, the grammar is much more likely to behave like real
R code.</p>
<p>R DSLs are traditionally implemented with a mix of both
principles. Expressions are parsed in ad hoc ways, but are
eventually evaluated in an environment containing dataframe
columns. While it is difficult to completely avoid ad hoc parsing,
tidyeval DSLs strive to rely on evaluation as much as possible.</p>
    
    <h2 class="hasAnchor" id="values-versus-expressions"><a class="anchor" href="#values-versus-expressions"></a>Values versus expressions</h2>

    
    <p>A corollary of emphasising evaluation is that your DSL functions
should understand <em>values</em> in addition to expressions. This is
especially important with <a href='quasiquotation.html'>quasiquotation</a>: users can bypass
symbolic evaluation completely by unquoting values. For instance,
the following expressions are completely equivalent:</p><pre># Taking an expression:
dplyr::mutate(mtcars, cyl2 = cyl * 2)
    # Taking a value:
var &lt;- mtcars$cyl * 2
dplyr::mutate(mtcars, cyl2 = !! var)
</pre><p><code>dplyr::mutate()</code> evaluates expressions in a context where
dataframe columns are in scope, but it accepts any value that can
be treated as a column (a recycled scalar or a vector as long as
there are rows).</p>
<p>A more complex example is <code>dplyr::select()</code>. This function
evaluates dataframe columns in a context where they represent
column positions. Therefore, <code>select()</code> understands column symbols
like <code>cyl</code>:</p><pre># Taking a symbol:
dplyr::select(mtcars, cyl)
    # Taking an unquoted symbol:
var &lt;- quote(sym)
dplyr::select(mtcars, !! var)
</pre>
    <p>But it also understands column positions:</p><pre># Taking a column position:
dplyr::select(mtcars, 2)
    # Taking an unquoted column position:
var &lt;- 2
dplyr::select(mtcars, !! var)
</pre>
    <p>Understanding values in addition to expressions makes your grammar
more consistent, predictable, and programmable.</p>
    
    <h2 class="hasAnchor" id="tidy-scoping"><a class="anchor" href="#tidy-scoping"></a>Tidy scoping</h2>

    
    <p>The special type of scoping found in R grammars implemented with
evaluation poses some challenges. Both objects from a dataset and
objects from the current environment should be in scope, with the
former having precedence over the latter. In other words, the
dataset should <em>overscope</em> the dynamic context. The traditional
solution to this issue in R is to transform a dataframe to an
environment and set the calling frame as the parent environment.
This way, the symbols appearing in the expression can refer to
their surrounding context in addition to dataframe columns. In
other words, the grammar implements correctly an important aspect
of R: <a href = 'http://adv-r.had.co.nz/Functions.html#lexical-scoping'>lexical scoping</a>.</p>
<p>Creating this scope hierarchy (data first, context next) is
possible because R makes it easy to capture the calling environment
(see <code><a href='caller_env.html'>caller_env()</a></code>). However, this supposes that captured
expressions were actually typed in the most immediate caller
frame. This assumption easily breaks in R. First because
quasiquotation allows an user to combine expressions that do not
necessarily come from the same lexical context. Secondly because
arguments can be forwarded through the special <code>...</code> argument.
While base R does not provide any way of capturing a forwarded
argument along with its original environment, rlang features
<code><a href='quosures.html'>quos()</a></code> for this purpose. This function looks up each forwarded
arguments and returns a list of <a href='quosure.html'>quosures</a> that bundle the
expressions with their own dynamic environments.</p>
<p>In that context, maintaining scoping consistency is a challenge
because we're dealing with multiple environments, one for each
argument plus one containing the overscoped data. This creates
difficulties regarding tidyeval's overarching principle that we
should change R semantics through evaluation. It is possible to
evaluate each expression in turn, but how can we combine all
expressions into one and evaluate it tidily at once? An expression
can only be evaluated in a single environment. This is where
quosures come into play.</p>
    
    <h2 class="hasAnchor" id="quosures-and-overscoping"><a class="anchor" href="#quosures-and-overscoping"></a>Quosures and overscoping</h2>

    
    <p>Unlike formulas, <a href='quosure.html'>quosures</a> aren't simple containers of an
expression and an environment. In the tidyeval framework, they have
the property of self-evaluating in their own environment. Hence
they can appear anywhere in an expression (e.g. by being
<a href='quasiquotation.html'>unquoted</a>), carrying their own environment and
behaving otherwise exactly like surrounding R code. Quosures behave
like reified
<a href = 'http://adv-r.had.co.nz/Computing-on-the-language.html#capturing-expressions'>promises</a>
that are unreified during tidy evaluation.</p>
<p>However, the dynamic environments of quosures do not contain
overscoped data. It's not of much use for sublanguages to get the
contextual environment right if they can't also change the meaning
of code quoted in quosures. To solve this issue, tidyeval rechains
the overscope to a quosure just before it self-evaluates. This way,
both the lexical environment and the overscoped data are in scope
when the quosure is evaluated. Is is evaluated tidily.</p>
<p>In practical terms, <code>eval_tidy()</code> takes a <code>data</code> argument and
creates an overscope suitable for tidy evaluation. In particular,
these overscopes contain definitions for self-evaluation of
quosures. See <code><a href='eval_tidy_.html'>eval_tidy_()</a></code> and <a href='as_overscope.html'>as_overscope</a> for more flexible
ways of creating overscopes.</p>
    
    <h2 class="hasAnchor" id="theory"><a class="anchor" href="#theory"></a>Theory</h2>

    
    <p>The most important concept of the tidy evaluation framework is that
expressions should be scoped in their dynamic context. This issue
is linked to the computer science concept of <em>hygiene</em>, which
roughly means that symbols should be scoped in their local context,
the context where they are typed by the user. In a way, hygiene is
what "tidy" refers to in "tidy evaluation".</p>
<p>In languages with macros, hygiene comes up for <a href = 'https://en.wikipedia.org/wiki/Hygienic_macro'>macroexpansion</a>. While
macros look like R's non-standard evaluation functions, and share
certain concepts with them (in particular, they get their arguments
as unevaluated code), they are actually quite different. Macros are
compile-time and therefore can only operate on code and constants,
never on user data. They also don't return a value but are expanded
in place by the compiler. In comparison, R does not have macros but
it has <a href = 'https://en.wikipedia.org/wiki/Fexpr'>fexprs</a>, i.e. regular
functions that get arguments as unevaluated expressions rather than
by their value (fexprs are what we call NSE functions in the R
community). Unlike macros, these functions execute at run-time and
return a value.</p>
<p>Symbolic hygiene is a problem for macros during expansion because
expanded code might invisibly redefine surrounding symbols.
Correspondingly, hygiene is an issue for NSE functions if the code
they captured gets evaluated in the wrong
environment. Historically, fexprs did not have this problem because
they existed in languages with dynamic scoping. However in modern
languages with lexical scoping, it is imperative to bundle quoted
expressions with their dynamic environment. The most natural way
to do this in R is to use formulas and quosures.</p>
<p>While formulas were introduced in the S language, the quosure was
invented much later for R <a href = 'https://github.com/wch/r-source/commit/a945ac8e6a82617205442d44a2be3a497d2ac896'>by Luke Tierney in2000</a>.
From that point on formulas recorded their environment along with
the model terms. In the Lisp world, the Kernel Lisp language also
recognised that arguments should be captured together with their
dynamic environment in order to solve hygienic evaluation in the
context of lexically scoped languages (see chapter 5 of <a href = 'https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/'>JohnSchutt's thesis</a>).
However, Kernel Lisp did not have quosures and avoided quotation or
quasiquotation operators altogether to avoid scoping issues.</p>
<p>Tidyeval's contributes to the problem of hygienic evaluation in
four ways:</p><ul>
<li><p>Promoting the quosure as the proper quotation data structure, in
order to keep track of the dynamic environment of quoted
expressions.</p></li>
<li><p>Introducing systematic quasiquotation in all capturing functions
in order to make it straightforward to program with these
functions.</p></li>
<li><p>Treating quosures as reified promises that self-evaluate within
their own environments. This allows unquoting quosures within
other quosures, which is the key for programming hygienically
with capturing functions.</p></li>
<li><p>Building a moving overscope that rechains to quosures as they get
evaluated. This makes it possible to change the evaluation
context and at the same time take the lexical context of each
quosure into account.</p></li>
</ul>
    
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <p><code><a href='eval_tidy.html'>eval_tidy()</a></code>, <code><a href='quosure.html'>quo()</a></code>, <a href='quasiquotation.html'>quasiquotation</a>.</p>
    

  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      
      <li><a href="#parsing-versus-evaluation">Parsing versus evaluation</a></li>

      <li><a href="#values-versus-expressions">Values versus expressions</a></li>

      <li><a href="#tidy-scoping">Tidy scoping</a></li>

      <li><a href="#quosures-and-overscoping">Quosures and overscoping</a></li>

      <li><a href="#theory">Theory</a></li>

      <li><a href="#see-also">See also</a></li>
          </ul>

  </div>
</div>

      <footer>
      <div class="tidyverse">
  <p>rlang is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href="http://tidyverse.org">tidyverse.org</a>.</p>
</div>

<div class="author">
  <p>Developed by <a href='http://hadley.nz'>Hadley Wickham</a>, Lionel Henry.</p>
  <p>Site built by <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67989-18', 'auto');
  ga('send', 'pageview');
</script>
      </footer>
   </div>

  </body>
</html>
