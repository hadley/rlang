% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnd-redispatch.R
\name{with_redispatch}
\alias{hnd_redispatch}
\alias{with_redispatch}
\alias{with_redispatch_}
\title{Evaluate an expression with a redispatch strategy.}
\usage{
with_redispatch(.expr, ..., .redispatch = list())

with_redispatch_(.expr, ..., .redispatch = list(), .env = NULL)

hnd_redispatch(..., .redispatch = list(), .env = env_caller())
}
\arguments{
\item{.expr}{An expression to evaluate with redispatch enabled. The
underscored version takes a quoted expression or a quoted
formula.}

\item{..., .redispatch}{A dictionary of generics. The names specify
the generics whose dispatching may fail, and the values should be
other generic functions (or their names) to redispatch to.}

\item{.env}{The evaluation environment. The redispatching methods
should be in scope in that environment. Defaults to the caller
environment.}
}
\description{
These functions establish redispatch strategies. They require that
the default method signals a \code{dispatch_miss} condition (see
\code{\link{dispatch_miss}()}) when method dispatch fails. For
instance it is useful to try dispatching with one generic then
another if no method is available. An important limitation of this
method is that the function signature of the new generic should be
compatible with the signature of the failing generic.
}
\details{
Technically, \code{with_redispatch()} establishes a restarting
handler (see \code{\link{restarting}()}) for conditions of type
\code{dispatch_miss}. These conditions should be signalled with
\code{\link{dispatch_miss}()}: this signalling function sets up a
recovery restart that provides a jump target for redispatched
generics. See \code{hnd_redispatch()} and \code{rst_redispatch()}
to set up a redispatch handler or restart manually.

Note that while these functions were designed with S3 generics in
mind, they can be applied more generally to any function able to
take an object signalled with \code{\link{dispatch_miss}()} as
first argument.
}
\examples{
# te default method for "my_generic" signals a dispatch failure:
my_generic <- function(x, ...) UseMethod("my_generic")
my_generic.bar <- function(x, ...) "bar"
my_generic.default <- function(x, ...) {
  msg <- "dispatch failure."
  dispatch_miss("my_generic", x, ..., .msg = msg)
}

foo_obj <- structure(NULL, class = "foo")

# If my_generic is called with a foo objects, redispatch fails:
\dontrun{
my_generic(foo_obj)
}

# If foo is handled by another generic with a compatible argument
# signature, it can be redispatched to that generic:
other_generic <- function(x) UseMethod("other_generic")
other_generic.foo <- function(x) "foo"
with_redispatch(my_generic = other_generic, my_generic(foo_obj))

# Note that it is important that my_generic() and other_generic()
# have a compatible signature, or at least are called in a
# compatible way. For instance other_generic does not accept
# additional arguments and will fail if not called appropriately:
\dontrun{
with_redispatch(my_generic = other_generic, my_generic(foo_obj, "arg"))
}
}
\seealso{
\code{\link{dispatch_miss}()} for signalling a dispatch
  failure, and \code{\link{rst_redispatch}()} to set up a
  redispatching restart manually.
}

